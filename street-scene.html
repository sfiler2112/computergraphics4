<!DOCTYPE html>
<meta charset="UTF-8">
<html>
<!--
    A scene of a street with different light settings for day and night.  Daytime will be lit with a directional light from above.  
    Night time will have streetlamps with pointlights and spotlights on cars.  Both times will have an additional viewpoint light with a lower intensity.
-->
    <head>
        <title>Street Scene</title>
        <style>
            body {
                background-color: #EEEEEE;
            }
            label {
                white-space: pre;
                margin-left: 25px;
            }
        </style>


        <script type="x-shader/x-vertex" id="vshader-source">
            attribute vec3 a_coords;
            attribute vec3 a_normal;
            attribute vec2 a_texCoords;
            uniform mat4 modelview;
            uniform mat4 projection;
            varying vec3 v_normal;
            varying vec3 v_eyeCoords;
            varying vec2 v_texCoords;
            void main() {
                vec4 coords = vec4(a_coords,1.0);
                vec4 eyeCoords = modelview * coords;
                gl_Position = projection * eyeCoords;
                v_normal = normalize(a_normal);
                v_eyeCoords = eyeCoords.xyz/eyeCoords.w;
                v_texCoords = a_texCoords;
            }
        </script>

        <script type="x-shader/x-fragment" id="fshader-source">
            #ifdef GL_FRAGMENT_PRECISION_HIGH
               precision highp float;
            #else
               precision mediump float;
            #endif
            struct MaterialProperties {
                vec4 diffuseColor;      // diffuseColor.a is alpha for the fragment
                vec3 specularColor;
                vec3 emissiveColor;
                float specularExponent;
            };
            struct LightProperties {
                bool enabled;
                vec4 position;
                vec3 color;
                float attenuation;   // Linear attenuation factor, >= 0. Only point lights attenuate.
                vec3 spotDirection;  // Note: only a point light can be a spotlight
                float spotCosineCutoff; // if <= 0, this is not a spotlight, if >= 1, the light cone shrinks to nothing
                float spotExponent;
            };
            uniform MaterialProperties material; // do two-sided lighting, but assume front and back materials are the same
            uniform LightProperties lights[4];
            uniform mat3 normalMatrix;
            uniform sampler2D u_texture;
            uniform bool useTexture; // initialized as false, must be set to true when creating an object with a texture
            varying vec3 v_normal;
            varying vec3 v_eyeCoords;
            varying vec2 v_texCoords;
            vec3 lightingEquation( LightProperties light, MaterialProperties material, 
                                        vec3 eyeCoords, vec3 N, vec3 V ) {
                   // N is normal vector, V is direction to viewer.
                vec3 L, R; // Light direction and reflected light direction.
                float spotFactor = 1.0;  // multiplier to account for spotlight
                float attenuationFactor = 1.0; // multiplier to account for light attenuation with distance
                if ( light.position.w == 0.0 ) {
                    L = normalize( light.position.xyz );
                }
                else {
                    L = normalize( light.position.xyz/light.position.w - v_eyeCoords );
                    if (light.spotCosineCutoff > 0.0) { // the light is a spotlight
                        vec3 D = -normalize(light.spotDirection);
                        float spotCosine = dot(D,L);
                        if (spotCosine >= light.spotCosineCutoff) { 
                            spotFactor = pow(spotCosine,light.spotExponent);
                        }
                        else { // The point is outside the cone of light from the spotlight.
                            spotFactor = 0.0; // The light will add no color to the point.
                        }
                    }
                    if (light.attenuation > 0.0) {
                        float dist = distance(eyeCoords,light.position.xyz/light.position.w);
                        attenuationFactor = 1.0 / (1.0 + dist*light.attenuation);
                    }
                }
                if (dot(L,N) <= 0.0) {
                    return vec3(0.0);
                }
                vec3 reflection;
                
                if(useTexture){
                    reflection = dot(L,N) * light.color * texture2D(u_texture, v_texCoords).rgb;
                } else {
                    reflection = dot(L,N) * light.color * material.diffuseColor.rgb;
                }

                R = -reflect(L,N);
                if (dot(R,V) > 0.0) {
                    float factor = pow(dot(R,V),material.specularExponent);
                    reflection += factor * material.specularColor * light.color;
                }
                return spotFactor*attenuationFactor*reflection;
            }
            void main() {
                vec3 normal = normalize( normalMatrix*v_normal );
                vec3 viewDirection = normalize( -v_eyeCoords);  // (Assumes a perspective projection.)
                vec3 color = material.emissiveColor;
                for (int i = 0; i < 4; i++) {
                    if (lights[i].enabled) { 
                        if (gl_FrontFacing) {
                            color += lightingEquation( lights[i], material, v_eyeCoords,
                                                            normal, viewDirection);
                        }
                        else {
                            color += lightingEquation( lights[i], material, v_eyeCoords,
                                                            -normal, viewDirection);
                        }
                    }
                }
                gl_FragColor = vec4(color,material.diffuseColor.a);
            }
        </script>


        <script src="gl-matrix-min.js"></script>
        <script src="trackball-rotator.js"></script>
        <script src="basic-object-models-IFS.js"></script>
        <script>

            "use strict";

            var gl;   // The webgl context.

            var a_coords_loc;         // Location of the a_coords attribute variable in the shader program.
            var a_normal_loc;         // Location of a_normal attribute 
            var a_texCoords_loc;      // Location of a_texCoords attribute

            var u_modelview;       // Locations for uniform matrices
            var u_projection;
            var u_normalMatrix;

            var u_material;     // An object tolds uniform locations for the material.
            var u_lights;       // An array of objects that holds uniform locations for light properties.
            var u_texture_loc; 
            var u_useTexture_loc;

            var projection = mat4.create();    // projection matrix
            var modelview;                     // modelview matrix; value comes from rotator
            var normalMatrix = mat3.create();  // matrix, derived from modelview matrix, for transforming normal vectors

            var rotator;  // A TrackballRotator to implement rotation by mouse.

            var frameNumber = 0;  // frame number during animation (actually only goes up by 0.5 per frame)

            var torus, sphere, cone, cylinder, disk, ring, cube;  // basic objects, created using function createModel

            var matrixStack = [];           // A stack of matrices for implementing hierarchical graphics.

            var currentColor = [1,1,1,1];   // The current diffuseColor; render() functions in the basic objects set
                                            // the diffuse color to currentColor when it is called before drawing the object.
                                            // Other color properties, which don't change often are handled elsewhere.

            var sunAngle = Math.PI/2; // rotation of the sun about the z-axis.
            var daytime = true;
            
            var turnAround = false; // when true the user is rotated 180 degrees.  0 degrees when false.
            var sidewalkPosition = -2; // starting position for the person
            var walkingSpeed = 0; // modified by walk-speed slider
            var directionModifier = 1; // walking to the right when positive, left when negative
            var personRotationValue = 2;

            var roadTextureObject;
            
            function draw() {
                gl.clearColor(.5,.81,.92,1);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                mat4.perspective(projection, Math.PI/4, 1, 1, 50);
                gl.uniformMatrix4fv(u_projection, false, projection );

                modelview = rotator.getViewMatrix();

                lights();

                world();
            }

            /* Set the direction vector of a light, in eye coordinates.
             * (Note: This function sets the value of the global variable normalMatrix.)
             * @param modelview the matrix that does object-to-eye coordinate transforms
             * @param u_direction_loc the uniform variable location for the spotDirection property of the light
             * @param lightDirection a vector that points in the direction that the spotlight is pointing (a vec3)
             */
            function setSpotlightDirection( u_direction_loc, modelview, lightDirection ) {
                mat3.normalFromMat4(normalMatrix,modelview);
                var transformedDirection = new Float32Array(3);
                vec3.transformMat3(transformedDirection, lightDirection, normalMatrix);
                gl.uniform3fv(u_direction_loc, transformedDirection);
            }

            /* Set the position of a light, in eye coordinates.
             * @param u_position_loc the uniform variable location for the position property of the light
             * @param modelview the matrix that does object-to-eye coordinate transforms
             * @param lightPosition the location of the light, in object coordinates (a vec4)
             */
            function setLightPosition( u_position_loc, modelview, lightPosition ) {
                var transformedPosition = new Float32Array(4);
                vec4.transformMat4(transformedPosition, lightPosition, modelview);
                gl.uniform4fv(u_position_loc, transformedPosition);
            }


            function lights() {

                
            }

            /**
             * Draws a "world" consisting of a disk holding some trees and a road, and a car that
             * drives along the road.  A tree in the middle grows from frame 0 to frame 1000.
             */
            function world() {
                pushMatrix();
                buildGround();
                pushMatrix();
                mat4.translate(modelview, modelview, [0,2,-10]);
                buildHouse();
                popMatrix();
                pushMatrix();
                mat4.translate(modelview, modelview, [0,0,-4]);
                buildStreetLights();
                popMatrix();
                pushMatrix();
                mat4.translate(modelview, modelview, [-2,0,-4]);
                buildMailbox();
                popMatrix();
                pushMatrix();
                
                
                mat4.translate(modelview, modelview, [sidewalkPosition,0,-3]);
            
                buildPerson();
                popMatrix();
                popMatrix();
            }
            
            
            
            function buildPerson(){
                pushMatrix();
                mat4.rotate(modelview,modelview,Math.PI/personRotationValue,[0,1,0]);
                pushMatrix();
                mat4.translate(modelview, modelview, [0,1.75,0]);
                buildHead();
                popMatrix();
                pushMatrix();
                mat4.translate(modelview, modelview, [0,1.2,0]);
                buildTorso();
                popMatrix();
                pushMatrix();
                mat4.translate(modelview, modelview, [0,.55,0]);
                buildLegs();
                popMatrix();
                popMatrix();
            }
            
            function buildLegs() {
                pushMatrix();
                currentColor = [.08, .37, .74, 1];
                mat4.scale(modelview, modelview, [.51,.7,.26]);
                cube.render();
                popMatrix();
            }
            
            function buildTorso(){
                pushMatrix();
                currentColor = [.6,0,.8,1];
                mat4.scale(modelview, modelview, [.5,.6,.25]);
                cube.render();
                popMatrix();
            }
            
            function buildHead(){
                pushMatrix();
                mat4.scale(modelview, modelview, [.25,.25,.25]);
                currentColor = [1,.8,.64,1];
                sphere.render();
                pushMatrix();
                currentColor = [1,0,0,1];
                mat4.rotate(modelview,modelview,(90)/180*Math.PI,[-1,0,0]);
                mat4.scale(modelview, modelview, [1.25, 1.25, 1]);
                cylinder.render();
                popMatrix();
                pushMatrix();
                buildEyes();
                popMatrix();
                popMatrix();
            }
            
            function buildEyes(){
                pushMatrix();
                currentColor = [0,0,1,1];
                mat4.scale(modelview, modelview, [.25, .25, .95]);
                pushMatrix();
                mat4.translate(modelview, modelview, [-1.75, 0, 0]);
                cylinder.render();
                popMatrix();
                pushMatrix();
                mat4.translate(modelview, modelview, [1.75, 0, 0]);
                cylinder.render();
                popMatrix();
                popMatrix();
            }
            
            function buildMailbox(){
                pushMatrix();
                currentColor = [.76,.6,.42,1];
                pushMatrix();
                mat4.rotate(modelview,modelview,(90)/180*Math.PI,[-1,0,0]);
                pushMatrix();
                mat4.scale(modelview, modelview, [.125, .125, 1]);
                cylinder.render();
                popMatrix();
                popMatrix();
                pushMatrix();
                mat4.translate(modelview, modelview, [0,1.125,0])
                mat4.scale(modelview, modelview, [.25,.25,.5]);
                var mailboxTop = createModel(uvCylinder(.5, 1, 32, true, false)); // create cylinder with no top
                mailboxTop.render();
                popMatrix();
                popMatrix();
            }
            function buildStreetLights(){
                pushMatrix();
                mat4.translate(modelview, modelview, [7.5,0,0]);
                buildStreetLamp();
                popMatrix();
                pushMatrix();
                mat4.translate(modelview, modelview, [-7.5,0,0]);
                buildStreetLamp();
                popMatrix();
            }
            
            function buildStreetLamp(){
                pushMatrix();
                currentColor = [.9,.9,.9,1];
                mat4.rotate(modelview,modelview,(90)/180*Math.PI,[-1,0,0]);
                pushMatrix();
                mat4.scale(modelview, modelview, [.125, .125, 3]);
                cylinder.render();
                popMatrix();
                buildStreetLampHead();
                popMatrix();
            }
            
            function buildStreetLampHead(){
                pushMatrix();
                mat4.translate(modelview, modelview,[0,0,3]);
                pushMatrix();
                mat4.scale(modelview,modelview, [.22,.22,.4]);
                cylinder.render();
                popMatrix();
                pushMatrix();
                mat4.translate(modelview, modelview,[0,0,.05]);
                mat4.scale(modelview,modelview, [.24,.24,.3]);
                currentColor = [1,1,0,1];
                cylinder.render();
                popMatrix();
                popMatrix();
            }
            
            
//            function loadTextures(){
//                
//                var roadImage = new Image();
//                
//                roadImage.onload = function() {
//                    gl.bindTexture(gl.TEXTURE_2D, roadTextureObject);
//                    try {
//                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, roadImage);
//                    }
//                    catch (e) {
//                        // Chrome, at least, gets a security error if it tries to use a local file.
//                        document.getElementById("headline").innerHTML =
//                            "Sorry, can't access textures.  Note that some<br>browsers can't use textures from a local disk.";
//                        return;
//                    }
//                    gl.generateMipmap(gl.TEXTURE_2D);
//                }
//                roadImage.src = "road2.png";
//            }
            
            function buildHouse() {
                pushMatrix();
                pushMatrix();
                currentColor = [.8,.25,.33,1];
                mat4.scale(modelview, modelview, [6,4,5]);
                cube.render();
                popMatrix();
                pushMatrix();
                buildRoof();
                popMatrix();
                popMatrix();
            }
            
            
            function buildRoof() {
                pushMatrix();
                mat4.translate(modelview, modelview, [0,3,0]);
                pushMatrix();
                mat4.rotate(modelview,modelview,.32175,[0,0,1]);
                buildLeftSideRoof();
                popMatrix();
                pushMatrix();
                mat4.rotate(modelview,modelview,.32175,[0,0,-1]);
                buildRightSideRoof();
                popMatrix();
                popMatrix();
            }
            
            function buildRightSideRoof() {
                pushMatrix();
                mat4.rotate(modelview,modelview,Math.PI,[0,1,0]);
                buildLeftSideRoof();
                popMatrix();
            }
            
            function buildLeftSideRoof() {
                pushMatrix();
                var coords = new Float32Array([-3.162,0,-3, 0,0,-3, 0,0,3, -3.162,0,3]);
                var normals = new Float32Array([0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0]);
                
                var coordsBuffer = gl.createBuffer();
                var normalBuffer = gl.createBuffer();;
                
                gl.bindBuffer(gl.ARRAY_BUFFER, coordsBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, coords, gl.STATIC_DRAW);

                gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);
                
                currentColor = [.9,.9,.9,1];
                gl.uniform4fv(u_material.diffuseColor, currentColor);

                gl.bindBuffer(gl.ARRAY_BUFFER, coordsBuffer);
                gl.vertexAttribPointer(a_coords_loc, 3, gl.FLOAT, false, 0, 0); // the vertex coordinates for the left side roof

                gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
                gl.vertexAttribPointer(a_normal_loc, 3, gl.FLOAT, false, 0, 0); // the normal vector for the left side roof
                
                gl.uniformMatrix4fv(u_modelview, false, modelview ); // send the modelview matrix to the shader
                mat3.normalFromMat4(normalMatrix, modelview); // create a matrix that will normalize the vectors for the left side roof in the shader 
                gl.uniformMatrix3fv(u_normalMatrix, false, normalMatrix); // send the normal matrix to the shader
                
                gl.drawArrays(gl.TRIANGLE_FAN, 0, 4); // render the left side roof.
                popMatrix();
            }
            
            function buildGround() {
                pushMatrix();
                mat4.rotate(modelview,modelview,(90)/180*Math.PI,[-1,0,0]);
                mat4.rotate(modelview,modelview,(90)/180*Math.PI,[0,0,1]);
                buildRoad();
                buildSidewalk();
                buildGrass();
                popMatrix();
            }
            
            function buildGrass() {
                pushMatrix();
                mat4.translate(modelview, modelview, [6.50,0,0])
                pushMatrix();
                var coords = new Float32Array([-3,-9,.125, 3,-9,.125, 3,9,.125, -3,9,.125]);
                var normals = new Float32Array([0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1]);
                
                var coordsBuffer = gl.createBuffer();
                var normalBuffer = gl.createBuffer();;
                
                gl.bindBuffer(gl.ARRAY_BUFFER, coordsBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, coords, gl.STATIC_DRAW);

                gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);
                
                currentColor = [0,1,0,1];
                gl.uniform4fv(u_material.diffuseColor, currentColor);

                gl.bindBuffer(gl.ARRAY_BUFFER, coordsBuffer);
                gl.vertexAttribPointer(a_coords_loc, 3, gl.FLOAT, false, 0, 0); // the vertex coordinates for the grass

                gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
                gl.vertexAttribPointer(a_normal_loc, 3, gl.FLOAT, false, 0, 0); // the normal vector for the grass 
                
                gl.uniformMatrix4fv(u_modelview, false, modelview ); // send the modelview matrix to the shader
                mat3.normalFromMat4(normalMatrix, modelview); // create a matrix that will normalize the vectors for the grass in the shader 
                gl.uniformMatrix3fv(u_normalMatrix, false, normalMatrix); // send the normal matrix to the shader
                
                gl.drawArrays(gl.TRIANGLE_FAN, 0, 4); // render the grass.
                
                popMatrix();
                popMatrix();
            }
            
            function buildSidewalk() {
                pushMatrix();
                currentColor = [.75,.75,.75,1];
                pushMatrix();
                mat4.translate(modelview, modelview, [-2.75,0,0.0625])
                mat4.scale(modelview, modelview, [1.5,18,0.125]);
                cube.render();
                popMatrix();
                pushMatrix();
                mat4.translate(modelview, modelview, [2.75,0,0.0625])
                mat4.scale(modelview, modelview, [1.5,18,0.125]);
                cube.render();
                popMatrix();
                popMatrix();
            }
            
            function buildRoad() {
                pushMatrix();
                var coords = new Float32Array([-2,-9,0, 2,-9,0, 2,9,0, -2,9,0]);
                var normals = new Float32Array([0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1]);
//                var texCoords = new Float32Array([0,0, 1,0, 1,1, 0,1]);
                
                var coordsBuffer = gl.createBuffer();
                var normalBuffer = gl.createBuffer();
                var texBuffer = gl.createBuffer();
                
                gl.bindBuffer(gl.ARRAY_BUFFER, coordsBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, coords, gl.STATIC_DRAW);

                gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);
                
//                gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
//                gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);
//                
//                gl.uniform1i(u_useTexture_loc, 1); // set useTexture to true
//                gl.activeTexture(gl.TEXTURE0);
//                gl.bindTexture(gl.TEXTURE_2D, roadTextureObject);
                
                currentColor = [.2,.2,.2,1];
                gl.uniform4fv(u_material.diffuseColor, currentColor);

                gl.bindBuffer(gl.ARRAY_BUFFER, coordsBuffer);
                gl.vertexAttribPointer(a_coords_loc, 3, gl.FLOAT, false, 0, 0); // the vertex coordinates for the road

                gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
                gl.vertexAttribPointer(a_normal_loc, 3, gl.FLOAT, false, 0, 0); // the normal vector for the road 

//                gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
//                gl.vertexAttribPointer(a_texCoords_loc, 2, gl.FLOAT, false, 0, 0);

                gl.uniformMatrix4fv(u_modelview, false, modelview ); // send the modelview matrix to the shader
                mat3.normalFromMat4(normalMatrix, modelview); // create a matrix that will normalize the vectors for the road in the shader 
                gl.uniformMatrix3fv(u_normalMatrix, false, normalMatrix); // send the normal matrix to the shader
                
                gl.drawArrays(gl.TRIANGLE_FAN, 0, 4); // render the road.
                popMatrix();
              //  gl.uniform1i(u_useTexture_loc, 0); // set useTexture back to false
            }

            /**
             * Draws a tree consisting of a green cone with a brown cylinder for a trunk.
             */
            function tree() {
                pushMatrix();
                mat4.rotate(modelview,modelview,(90)/180*Math.PI,[-1,0,0]);
                pushMatrix();
                currentColor = [0.5,0.3,0.1,1];
                mat4.scale(modelview,modelview,[0.5,0.5,1]);
                cylinder.render();
                popMatrix();
                pushMatrix();
                currentColor = [0,0.8,0,1];
                mat4.translate(modelview,modelview,[0,0,0.8]);
                mat4.scale(modelview,modelview,[1.5,1.5,2]);
                cone.render();
                popMatrix();
                popMatrix();
            }

            

            

            /**
             *  Push a copy of the current modelview matrix onto the matrix stack.
             */
            function pushMatrix() {
                matrixStack.push( mat4.clone(modelview) );
            }


            /**
             *  Restore the modelview matrix to a value popped from the matrix stack.
             */
            function popMatrix() {
                modelview = matrixStack.pop();
            }

            /**
             *  Create one of the basic objects.  The modelData holds the data for
             *  an IFS using the structure from basic-objects-IFS.js.  This function
             *  creates VBOs to hold the coordinates, normal vectors, and indices
             *  from the IFS, and it loads the data into those buffers.  The function
             *  creates a new object whose properties are the identifies of the
             *  VBOs.  The new object also has a function, render(), that can be called to
             *  render the object, using all the data from the buffers.  That object
             *  is returned as the value of the function.  (The second parameter,
             *  xtraTranslate, is there because this program was ported from a Java
             *  version where cylinders were created in a different position, with
             *  the base on the xy-plane instead of with their center at the origin.
             *  The xtraTranslate parameter is a 3-vector that is applied as a
             *  translation to the rendered object.  It is used to move the cylinders
             *  into the position expected by the code that was ported from Java.)
             */
            function createModel(modelData, xtraTranslate) {
                var model = {};
                model.coordsBuffer = gl.createBuffer();
                model.normalBuffer = gl.createBuffer();
                model.indexBuffer = gl.createBuffer();
                model.count = modelData.indices.length;
                if (xtraTranslate)
                    model.xtraTranslate = xtraTranslate;
                else
                    model.xtraTranslate = null;
                gl.bindBuffer(gl.ARRAY_BUFFER, model.coordsBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, modelData.vertexPositions, gl.STATIC_DRAW);
                gl.bindBuffer(gl.ARRAY_BUFFER, model.normalBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, modelData.vertexNormals, gl.STATIC_DRAW);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, model.indexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, modelData.indices, gl.STATIC_DRAW);
                model.render = function() {  // This function will render the object.
                       // Since the buffer from which we are taking the coordinates and normals
                       // change each time an object is drawn, we have to use gl.vertexAttribPointer
                       // to specify the location of the data. And to do that, we must first
                       // bind the buffer that contains the data.  Similarly, we have to
                       // bind this object's index buffer before calling gl.drawElements.
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.coordsBuffer);
                    gl.vertexAttribPointer(a_coords_loc, 3, gl.FLOAT, false, 0, 0);
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.normalBuffer);
                    gl.vertexAttribPointer(a_normal_loc, 3, gl.FLOAT, false, 0, 0);
                    gl.uniform4fv(u_material.diffuseColor, currentColor);
                    if (this.xtraTranslate) {
                        pushMatrix();
                        mat4.translate(modelview,modelview,this.xtraTranslate);
                    }
                    gl.uniformMatrix4fv(u_modelview, false, modelview );
                    mat3.normalFromMat4(normalMatrix, modelview);
                    gl.uniformMatrix3fv(u_normalMatrix, false, normalMatrix);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                    gl.drawElements(gl.TRIANGLES, this.count, gl.UNSIGNED_SHORT, 0);
                    if (this.xtraTranslate) {
                        popMatrix();
                    }
                }
                return model;
            }


            /* Creates a program for use in the WebGL context gl, and returns the
             * identifier for that program.  If an error occurs while compiling or
             * linking the program, an exception of type String is thrown.  The error
             * string contains the compilation or linking error.  If no error occurs,
             * the program identifier is the return value of the function.
             *    The second and third parameters are the id attributes for <script>
             * elementst that contain the source code for the vertex and fragment
             * shaders.
             */
            function createProgram(gl, vertexShaderID, fragmentShaderID) {
                function getTextContent( elementID ) {
                        // This nested function retrieves the text content of an
                        // element on the web page.  It is used here to get the shader
                        // source code from the script elements that contain it.
                    var element = document.getElementById(elementID);
                    var node = element.firstChild;
                    var str = "";
                    while (node) {
                        if (node.nodeType == 3) // this is a text node
                            str += node.textContent;
                        node = node.nextSibling;
                    }
                    return str;
                }
                try {
                    var vertexShaderSource = getTextContent( vertexShaderID );
                    var fragmentShaderSource = getTextContent( fragmentShaderID );
                }
                catch (e) {
                    throw "Error: Could not get shader source code from script elements.";
                }
                var vsh = gl.createShader( gl.VERTEX_SHADER );
                gl.shaderSource(vsh,vertexShaderSource);
                gl.compileShader(vsh);
                if ( ! gl.getShaderParameter(vsh, gl.COMPILE_STATUS) ) {
                    throw "Error in vertex shader:  " + gl.getShaderInfoLog(vsh);
                 }
                var fsh = gl.createShader( gl.FRAGMENT_SHADER );
                gl.shaderSource(fsh, fragmentShaderSource);
                gl.compileShader(fsh);
                if ( ! gl.getShaderParameter(fsh, gl.COMPILE_STATUS) ) {
                   throw "Error in fragment shader:  " + gl.getShaderInfoLog(fsh);
                }
                var prog = gl.createProgram();
                gl.attachShader(prog,vsh);
                gl.attachShader(prog, fsh);
                gl.linkProgram(prog);
                if ( ! gl.getProgramParameter( prog, gl.LINK_STATUS) ) {
                   throw "Link error in program:  " + gl.getProgramInfoLog(prog);
                }
                return prog;
            }



            /* Initialize the WebGL context.  Called from init() */
            function initGL() {
                var prog = createProgram(gl,"vshader-source","fshader-source");
                gl.useProgram(prog);
                gl.enable(gl.DEPTH_TEST);

                /* Get attribute and uniform locations */

                a_coords_loc =  gl.getAttribLocation(prog, "a_coords");
                a_normal_loc =  gl.getAttribLocation(prog, "a_normal");
//                a_texCoords_loc = gl.getAttribLocation(prog, "a_texCoords");
                gl.enableVertexAttribArray(a_coords_loc);
                gl.enableVertexAttribArray(a_normal_loc);
//                gl.enableVertexAttribArray(a_texCoords_loc);

                u_modelview = gl.getUniformLocation(prog, "modelview");
                u_projection = gl.getUniformLocation(prog, "projection");
                u_normalMatrix =  gl.getUniformLocation(prog, "normalMatrix");
                u_material = {
                    diffuseColor: gl.getUniformLocation(prog, "material.diffuseColor"),
                    specularColor: gl.getUniformLocation(prog, "material.specularColor"),
                    emissiveColor: gl.getUniformLocation(prog, "material.emissiveColor"),
                    specularExponent: gl.getUniformLocation(prog, "material.specularExponent")
                };
                u_lights = new Array(4);
                for (var i = 0; i < 4; i++) {
                    u_lights[i] = {
                        enabled: gl.getUniformLocation(prog, "lights[" + i + "].enabled"),
                        position: gl.getUniformLocation(prog, "lights[" + i + "].position"),
                        color: gl.getUniformLocation(prog, "lights[" + i + "].color"),
                        spotDirection: gl.getUniformLocation(prog, "lights[" + i + "].spotDirection"),
                        spotCosineCutoff: gl.getUniformLocation(prog, "lights[" + i + "].spotCosineCutoff"),
                        spotExponent: gl.getUniformLocation(prog, "lights[" + i + "].spotExponent"),
                        attenuation: gl.getUniformLocation(prog, "lights[" + i + "].attenuation")
                    };
                }

                u_texture_loc = gl.getUniformLocation(prog, "u_texture");
                gl.uniform1i(u_texture_loc, 0);
                u_useTexture_loc = gl.getUniformLocation(prog, "u_useTexture");
                gl.uniform1i(u_useTexture_loc, 0); // default, will use material diffusive instead of a texture.
                
                gl.uniform3f( u_material.specularColor, 0.1, 0.1, 0.1 );  // specular properties don't change
                gl.uniform1f( u_material.specularExponent, 16 );
                gl.uniform3f( u_material.emissiveColor, 0, 0, 0);  // default, will be changed temporarily for some objects


                for (var i = 1; i < 4; i++) { // set defaults for lights
                    gl.uniform1i( u_lights[i].enabled, 0 ); 
                    gl.uniform4f( u_lights[i].position, 0, 0, 1, 0 );
                    gl.uniform1f( u_lights[i].spotCosineCutoff, 0); // not a spotlight
                    gl.uniform3f( u_lights[i].spotDirection, 0,0,-1);
                    gl.uniform1f( u_lights[i].spotExponent, 5);
                    gl.uniform1f( u_lights[i].attenuation, 0); // no attenuation
                    gl.uniform3f( u_lights[i].color, 1,1,1 ); 
                }

                gl.uniform1i( u_lights[0].enabled, 1 );   // viewpoint light
                gl.uniform4f( u_lights[0].position, 0,0,0,1 ); // positional, at viewpoint
                gl.uniform3f( u_lights[0].color, 0.2,0.2,0.2 );  // dim

                gl.uniform1i( u_lights[1].enabled, 1 );   // the sun during the day, the lamp at night

                gl.uniform1f( u_lights[2].spotCosineCutoff, Math.cos(Math.PI/8) ); // lights 2 and 3 are headlights,
                gl.uniform1f( u_lights[3].spotCosineCutoff, Math.cos(Math.PI/8) ); //    which are spotlights
                gl.uniform3f( u_lights[2].color, 0.5, 0.5, 0.4 );  
                gl.uniform3f( u_lights[3].color, 0.5, 0.5, 0.4 );
                
//                roadTextureObject = gl.createTexture();
//                loadTextures();

                // Note: position and spot direction for lights 1 to 4 are managed by modeling transforms.

            } // end initGL()



            //--------------------------------- animation framework ------------------------------


            var animating = false;

            function frame() {
                if (animating) {
                    frameNumber += 1;
                    
                    
                    if(sidewalkPosition > 8){
                        turnAround = true;
                        directionModifier = -1;
                        personRotationValue *= -1;
                        console.log("big sidewalkPostion: " + sidewalkPosition);
                    } else if ( sidewalkPosition < -8){
                        turnAround = true;
                        directionModifier = 1;
                        personRotationValue *= -1
                        console.log("small sidewalkPostion: " + sidewalkPosition);
                    } else {
//                        personRotationValue = 0;
                    }
                    
                    walkingSpeed = document.getElementById("walk-speed").value * .05 * directionModifier;
                    
                    sidewalkPosition += walkingSpeed;
                    
                    if(frameNumber%10 === 0){ //every 10 frames
                        console.log(frameNumber);
                        console.log("personrotation: " + personRotationValue);
                    }
                    
                    daytime = sunAngle < Math.PI;
                    draw();
                    requestAnimationFrame(frame);
                }
            }

            function setAnimating(run) {
                if (run != animating) {
                    animating = run;
                    if (animating)
                        requestAnimationFrame(frame);
                }
            }

            //-------------------------------------------------------------------------


            /**
             * initialization function that will be called when the page has loaded
             */
            function init() {
                try {
                    var canvas = document.getElementById("webglcanvas");
                    gl = canvas.getContext("webgl") || 
                                     canvas.getContext("experimental-webgl");
                    if ( ! gl ) {
                        throw "Browser does not support WebGL";
                    }
                }
                catch (e) {
                    document.getElementById("message").innerHTML =
                        "<p>Sorry, could not get a WebGL graphics context.</p>";
                    return;
                }
                try {
                    initGL();  // initialize the WebGL graphics context
                }
                catch (e) {
                    document.getElementById("message").innerHTML =
                        "<p>Sorry, could not initialize the WebGL graphics context:" + e + "</p>";
                    return;
                }
                document.getElementById("animCheck").checked = false;
                document.getElementById("reset").onclick = function() {
                   rotator.setView(17,[0,1,2]);
                   frameNumber = 0;
                   sunAngle = Math.PI/2;
                   daytime = true;
                   animating = false;
                   document.getElementById("animCheck").checked = false;
                   draw();
                }

                torus = createModel(uvTorus(0.5,1,16,8));   // Create all the basic objects.
                sphere = createModel(uvSphere(1));
                cone = createModel(uvCone(),[0,0,.5]);
                cylinder = createModel(uvCylinder(),[0,0,.5]);
                disk = createModel(uvCylinder(5.5,0.5,64),[0,0,.25]);
                ring = createModel(ring(3.3,4.8,40));
                cube = createModel(cube());

                rotator = new TrackballRotator(canvas,function() {
                    if (!animating)
                       draw();
                },17,[0,1,2]);
                draw();
            }

        </script>
    </head>
    <body onload="init()">

        <h2 id="headline">Street Scene</h2>


        <noscript><hr><h3>This page requires Javascript and a web browser that supports WebGL</h3><hr></noscript>

        <p id="message" style="font-weight:bold">Drag your mouse on the model to rotate it.<br>
        Use the slider bar to control the walkers's speed</p>

        <p>
           <label><input type="checkbox" id="animCheck" onchange="setAnimating(this.checked)">Animate</label>
            <label><input id="walk-speed" type="range" min="1" max="10" value="5">Walking Speed </label>
           <button id="reset" style="margin-left:40px">Reset</button>
        </p>


        <div>

            <canvas width=600 height=600 id="webglcanvas" style="background-color:blue"></canvas>

        </div>
    </body>
</html>